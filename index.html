<!DOCTYPE html>
<html>
<head>
  <style>
  canvas {
    border: 1px solid #000;
    touch-action: none; /* Disable default gestures */
    max-width: 100%;
    height: auto;
  }
  #drawCanvas {
    width: 90vw;
    height: 90vw;
    max-width: 280px;
    max-height: 280px;
  }
</style>

  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
</head>
<body>

<!-- Drawing canvas -->
<canvas id="drawCanvas" width="280" height="280"></canvas>

<!-- Preview canvas -->
<canvas id="previewCanvas" width="28" height="28"></canvas>


<br>
<button onclick="centerAndScaleDigit()">Preview</button>
<button onclick="clearCanvas()">Clear</button>
<button id="predictId" onclick="predict">Predict</button>
<br>
<span id="predictionText" style="font-size: 20px; margin-left: 20px;"></span>
<br>
<br>
1. Draw a digit in big box<br>
2. Preview what model sees in small box<br>
3. Predict!<br>
4. Clear<br>
5. Repeat<br>

<script>
const drawCanvas = document.getElementById("drawCanvas");
const ctx = drawCanvas.getContext("2d");

let drawing = false;
ctx.fillStyle = "white";
ctx.fillRect(0, 0, drawCanvas.width, drawCanvas.height);

// Mouse
drawCanvas.addEventListener("mousedown", (e) => {
  drawing = true;
  ctx.beginPath();
  ctx.moveTo(e.offsetX, e.offsetY);
});
drawCanvas.addEventListener("mousemove", (e) => {
  if (!drawing) return;
  ctx.lineTo(e.offsetX, e.offsetY);
  ctx.strokeStyle = "black";
  ctx.lineWidth = 15;
  ctx.lineCap = "round";
  ctx.lineJoin = "round";
  ctx.stroke();
});
drawCanvas.addEventListener("mouseup", () => drawing = false);
drawCanvas.addEventListener("mouseleave", () => drawing = false);

// Touch
drawCanvas.addEventListener("touchstart", (e) => {
  e.preventDefault();
  const rect = drawCanvas.getBoundingClientRect();
  const x = e.touches[0].clientX - rect.left;
  const y = e.touches[0].clientY - rect.top;
  drawing = true;
  ctx.beginPath();
  ctx.moveTo(x * (drawCanvas.width / rect.width), y * (drawCanvas.height / rect.height));
});

drawCanvas.addEventListener("touchmove", (e) => {
  e.preventDefault();
  if (!drawing) return;
  const rect = drawCanvas.getBoundingClientRect();
  const x = e.touches[0].clientX - rect.left;
  const y = e.touches[0].clientY - rect.top;
  ctx.lineTo(x * (drawCanvas.width / rect.width), y * (drawCanvas.height / rect.height));
  ctx.strokeStyle = "black";
  ctx.lineWidth = 15;
  ctx.lineCap = "round";
  ctx.lineJoin = "round";
  ctx.stroke();
});
drawCanvas.addEventListener("touchend", () => drawing = false);
drawCanvas.addEventListener("touchcancel", () => drawing = false);

// Clear function (no change)
function clearCanvas() {
  ctx.fillStyle = "white";
  ctx.fillRect(0, 0, drawCanvas.width, drawCanvas.height);
  const previewCtx = document.getElementById("previewCanvas").getContext("2d");
  previewCtx.fillStyle = "white";
  previewCtx.fillRect(0, 0, 28, 28);
}

// Preview and predict (same as before)...

//document.getElementById("predictId").addEventListener("click", predict);


function centerAndScaleDigit() {
  const srcCtx = drawCanvas.getContext("2d");
  const srcImage = srcCtx.getImageData(0, 0, 280, 280);
  const data = srcImage.data;

  // Bounding box detection
  let top = 280, bottom = 0, left = 280, right = 0;
  for (let y = 0; y < 280; y++) {
    for (let x = 0; x < 280; x++) {
      const i = (y * 280 + x) * 4;
      const r = data[i], g = data[i+1], b = data[i+2];
      const gray = (r + g + b) / 3;
      if (gray < 255) {
        if (x < left) left = x;
        if (x > right) right = x;
        if (y < top) top = y;
        if (y > bottom) bottom = y;
      }
    }
  }

  if (left >= right || top >= bottom) {
    console.log("No digit detected.");
    return;
  }

  const width = right - left;
  const height = bottom - top;

  const tempCanvas = document.createElement("canvas");
  tempCanvas.width = width;
  tempCanvas.height = height;
  const tempCtx = tempCanvas.getContext("2d");

  tempCtx.drawImage(drawCanvas, left, top, width, height, 0, 0, width, height);

  const previewCanvas = document.getElementById("previewCanvas");
  const previewCtx = previewCanvas.getContext("2d");

  previewCtx.fillStyle = "white";
  previewCtx.fillRect(0, 0, 28, 28);

  const scale = Math.min(20 / width, 20 / height);
  const scaledWidth = Math.round(width * scale);
  const scaledHeight = Math.round(height * scale);

  const offsetX = Math.floor((28 - scaledWidth) / 2);
  const offsetY = Math.floor((28 - scaledHeight) / 2);

  previewCtx.drawImage(tempCanvas, 0, 0, width, height, offsetX, offsetY, scaledWidth, scaledHeight);
}


function getImageTensorFromCanvas() {
  const previewCanvas = document.getElementById("previewCanvas");
  const previewCtx = previewCanvas.getContext("2d");
  const imgData = previewCtx.getImageData(0, 0, 28, 28).data;

  const input = new Float32Array(1 * 1 * 28 * 28);

  for (let i = 0; i < 28 * 28; i++) {
    const r = imgData[i * 4];
    const g = imgData[i * 4 + 1];
    const b = imgData[i * 4 + 2];

    // Convert RGB to grayscale
    const gray = (r + g + b) / 3;

    // Normalize to [0, 1], invert if needed (MNIST uses white bg, black digit)
    input[i] = (255 - gray) / 255.0;
  }

  // Create ONNX tensor
  const inputTensor = new ort.Tensor("float32", input, [1, 1, 28, 28]);
  return inputTensor;
}

async function predict() {
  try {
    const inputTensor = getImageTensorFromCanvas();
    const session = await ort.InferenceSession.create("infer.onnx");
    const results = await session.run({ "input.1": inputTensor });
    const output = results["21"]["data"];
    console.log(output)
    const predictedDigit = output.indexOf(Math.max(...output));
    console.log("Predicted digit:", predictedDigit);
    document.getElementById("predictionText").textContent = `Prediction: ${predictedDigit}`;
  } catch (err) {
    console.error("Inference failed", err);
    document.getElementById("predictionText").textContent = `Error`;
  }
}

document.getElementById("predictId").addEventListener("click", predict );


</script>
</body>
</html>

